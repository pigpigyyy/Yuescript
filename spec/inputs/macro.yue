$ ->
	package.yuepath = "?.yue;./spec/inputs/?.yue"

import "macro-export" as {
	$, -- import all macros
	$config:$myconfig, -- rename macro $config to $myconfig
}

$asserts item == nil

$myconfig false

v = $assert item == nil

macro and = (...)->
	values = [value for value in *{...}]
	$showMacro "and", "#{ table.concat values, " and " }"

if $and f1!
	print "OK"

if $and f1!, f2!, f3!
	print "OK"

macro in = (target, ...)->
	values = [value for value in *{...}]
	$showMacro "in", table.concat ["#{target} == #{item}" for item in *values], " or "

if x |> $in "Apple", "Pig", "Dog"
	print "exist"

macro map = (items, action)->
	$showMacro "map", "[#{action} for _ in *#{items}]"

macro filter = (items, action)->
	$showMacro "filter", "[_ for _ in *#{items} when #{action}]"

macro reduce = (items, def, action)->
	$showMacro "reduce", "if ##{items} == 0
	#{def}
else
	_1 = #{def}
	for _2 in *#{items}
		_1 = #{action}
	_1"

macro foreach = (items, action)->
	$showMacro "foreach", "for _ in *#{items}
	#{action}"

macro pipe = (...)->
	switch select "#", ...
		when 0 then return ""
		when 1 then return ...
	ops = {...}
	last = ops[1]
	stmts = for i = 2, #ops
		stmt = "\tlocal _#{i} = #{last} |> #{ops[i]}"
		last = "_#{i}"
		stmt
	res = "do
#{table.concat stmts, "\n"}
	#{last}"
	$showMacro "pipe", res

{1,2,3} |> $map(_ * 2) |> $filter(_ > 4) |> $foreach print _

$foreach $filter($map({1,2,3}, _ * 2), _ > 4), print _

val = $pipe(
	{1, 2, 3}
	$map(_ * 2)
	$filter(_ > 4)
	$reduce(0, _1 + _2)
)

macro plus = (a, b)-> "#{a} + #{b}"

$plus(1,2)\call 123

res = 1 |> $plus 2

macro curry = (...)->
	args = {...}
	len = #args
	body = args[len]
	def = table.concat ["(#{args[i]})->" for i = 1, len - 1]
	"#{def}\n#{body\gsub "^do%s*\n",""}"

f = $curry x,y,z,do
	print x,y,z

macro get_inner = (var)-> "do
	a = 1
	a + 1"

macro get_inner_hygienic = (var)-> "(->
	local a = 1
	a + 1)!"

do
	a = 8
	a = $get_inner!
	a += $get_inner!
	print a

do
	a = 8
	a = $get_inner_hygienic!
	a += $get_inner_hygienic!
	print a

macro lua = (codes)-> {
	:codes
	type: "lua"
}

x = 0

$lua [[
local function f(a)
	return a + 1
end
x = x + f(3)
]]

$lua[[
function tb:func()
	print(123)
end
]]

print x

macro def = (fname, ...)->
	args = {...}
	last = table.remove args
	{
		codes: $showMacro "def", "local function #{fname}(#{table.concat args, ', '})
	#{last}
end"
		type: "lua"
	}

sel = (a, b, c)-> if a then b else c

$def sel, a, b, c, [[
	if a then
		return b
	else
		return c
	end
]]

$def dummy,[[]]

macro insertComment = (text)-> {
	codes: "-- #{text\match '[\'"](.*)[\'"]'}"
	type: "lua"
}

$insertComment "a comment here"

import 'underscore' as _

macro chain = (...)->
	callable = nil
	for item in *{...}
		callable = callable? and "(#{callable})\\#{item}" or item
	$showMacro "chain", callable

a = $chain(
	_{1, 2, 3, 4, -2, 3}
	chain!
	map => @ * 2
	filter => @ > 3
	value!
)

$chain(
	_{1, 2, 3, 4, -2, 3}
	chain!
	map => @ * 2
	filter => @ > 3
	each => print @
)

result = $chain(
	origin.transform.root.gameObject\Parents!
	Descendants!
	SelectEnable!
	SelectVisible!
	TagEqual "fx"
	Where (x) -> x.name\EndsWith "(Clone)"
	Destroy!
)

macro chainB = (...)->
	switch select "#", ...
		when 0 then return ""
		when 1 then return ...
	items = {...}
	last = nil
	stmts = for i = 1,#items
		stmt = if i == #items
			lastStr = last and "#{last}\\" or ""
			"\t#{lastStr}#{items[i]}"
		else
			lastStr = last and "#{last}\\" or ""
			"\tlocal _#{i} = #{lastStr}#{items[i]}"
		last = "_#{i}"
		stmt
	res = "do
#{table.concat stmts, '\n'}
"
	$showMacro "chainB", res

$chainB(
	origin.transform.root.gameObject\Parents!
	Descendants!
	SelectEnable!
	SelectVisible!
	TagEqual "fx"
	Where (x) -> x.name\EndsWith "(Clone)"
	Destroy!
)

macro chainC = (...)->
	import "moonp" as {:to_lua}
	callable = nil
	config = {
		implicit_return_root: false
		reserve_line_number: false
	}
	for item in *{...}
		if callable?
			callable = "#{callable}:#{to_lua(item,config)\gsub '%s*$',''}"
		else
			callable = to_lua(item,config)\gsub '%s*$',''
	{
		codes: $showMacro "chainC", callable
		type: "lua"
	}

$chainC(
	origin.transform.root.gameObject\Parents!
	Descendants!
	SelectEnable!
	SelectVisible!
	TagEqual "fx"
	Where (x) -> x.name\EndsWith "(Clone)"
	Destroy!
)

macro implicitReturnMacroIsAllowed = -> "print 'abc'\n123"

$implicitReturnMacroIsAllowed!

